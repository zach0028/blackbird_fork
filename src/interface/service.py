"""Helpers that expose Blackbird's core features to graphical/web interfaces."""
from __future__ import annotations

import io
import json
import time
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional

from rich.console import Console

import config
from modules.core.email import verifyEmail
from modules.core.username import verifyUsername
from modules.utils.userAgent import getRandomUserAgent
from modules.whatsmyname.list_operations import readList


class SearchServiceError(RuntimeError):
    """Raised when the search service cannot be executed."""


@dataclass
class MetadataItem:
    """Metadata extracted for a found account."""

    name: str
    value: Any
    raw: Dict[str, Any] = field(default_factory=dict)


@dataclass
class AccountResult:
    """Represents a single site where the account was discovered."""

    name: str
    url: str
    category: str
    metadata: List[MetadataItem] = field(default_factory=list)


@dataclass
class SearchOutcome:
    """Formatted result returned to consumer interfaces."""

    success: bool
    query: str
    search_type: str
    accounts: List[AccountResult] = field(default_factory=list)
    log: str = ""
    error: Optional[str] = None
    elapsed: Optional[float] = None


def _ensure_json_file(path: Path, description: str) -> None:
    """Validate that a JSON file exists and is readable."""

    if not path.exists():
        raise SearchServiceError(
            f"{description} is missing (expected at {path}). Run the CLI once to download the data."
        )

    try:
        # We only care that the JSON parses correctly; the value isn't needed here.
        json.loads(path.read_text(encoding="utf-8"))
    except json.JSONDecodeError as exc:  # pragma: no cover - defensive guard
        raise SearchServiceError(
            f"{description} could not be parsed: {exc.msg}. Try updating the site list."
        ) from exc


def _build_console() -> tuple[Console, io.StringIO]:
    """Create a Rich console that captures output into a buffer."""

    buffer = io.StringIO()
    console = Console(file=buffer, record=True, force_terminal=True, width=120)
    return console, buffer


def _prepare_config(
    *,
    console: Console,
    verbose: bool,
    filter_text: Optional[str],
    include_nsfw: bool,
    max_concurrent_requests: int,
) -> None:
    """Populate the global config module with sane defaults for programmatic use."""

    config.console = console
    config.verbose = verbose
    config.filter = filter_text
    config.no_nsfw = not include_nsfw
    config.max_concurrent_requests = max(1, max_concurrent_requests)

    config.username = None
    config.username_file = None
    config.email = None
    config.email_file = None
    config.permute = False
    config.permuteall = False
    config.csv = False
    config.pdf = False
    config.json = False
    config.ai = False
    config.setup_ai = False
    config.dump = False
    config.proxy = None
    config.timeout = 30
    config.no_update = True

    config.dateRaw = datetime.now().strftime("%m_%d_%Y")
    config.datePretty = datetime.now().strftime("%B %d, %Y")
    config.userAgent = getRandomUserAgent(config)

    config.usernameFoundAccounts = None
    config.emailFoundAccounts = None
    config.currentUser = None
    config.currentEmail = None
    config.saveDirectory = None
    config.metadata_params = None


def _format_metadata(items: Optional[Iterable[Dict[str, Any]]]) -> List[MetadataItem]:
    formatted: List[MetadataItem] = []
    if not items:
        return formatted

    for item in items:
        name = item.get("name", "Metadata")
        value = item.get("value")
        formatted.append(MetadataItem(name=name, value=value, raw=dict(item)))
    return formatted


def _format_accounts(results: Iterable[Dict[str, Any]]) -> List[AccountResult]:
    accounts: List[AccountResult] = []
    for account in results:
        accounts.append(
            AccountResult(
                name=account.get("name", ""),
                url=account.get("url", ""),
                category=account.get("category", "unknown"),
                metadata=_format_metadata(account.get("metadata")),
            )
        )
    return accounts


def search_username(
    username: str,
    *,
    filter_text: Optional[str] = None,
    include_nsfw: bool = True,
    verbose: bool = False,
    max_concurrent_requests: int = 20,
) -> SearchOutcome:
    """Search for accounts that match a username.

    The returned outcome contains formatted account information alongside the
    textual log generated by Blackbird.
    """

    username = username.strip()
    console, buffer = _build_console()
    _prepare_config(
        console=console,
        verbose=verbose,
        filter_text=filter_text,
        include_nsfw=include_nsfw,
        max_concurrent_requests=max_concurrent_requests,
    )

    if not username:
        return SearchOutcome(
            success=False,
            query=username,
            search_type="username",
            error="A username is required to run the search.",
            log="",
        )

    _ensure_json_file(Path(config.USERNAME_LIST_PATH), "Username site list")
    _ensure_json_file(Path(config.USERNAME_METADATA_LIST_PATH), "Username metadata list")

    config.currentUser = username

    try:
        username_data = readList("username", config)
        metadata_params = readList("metadata", config)
    except (OSError, json.JSONDecodeError) as exc:  # pragma: no cover - defensive guard
        raise SearchServiceError("Unable to read username site definitions.") from exc

    config.metadata_params = metadata_params
    sites = username_data.get("sites", [])

    try:
        start = time.perf_counter()
        results = verifyUsername(username, config, sites, metadata_params)
        elapsed = time.perf_counter() - start
    except Exception as exc:  # pragma: no cover - defensive guard
        log_text = console.export_text(clear=False)
        raise SearchServiceError("Username search failed. See the log for details.") from exc

    log_text = console.export_text(clear=False)
    accounts = _format_accounts(results)

    return SearchOutcome(
        success=True,
        query=username,
        search_type="username",
        accounts=accounts,
        log=log_text,
        elapsed=elapsed,
    )


def search_email(
    email: str,
    *,
    include_nsfw: bool = True,
    verbose: bool = False,
    max_concurrent_requests: int = 20,
) -> SearchOutcome:
    """Search for accounts associated with an e-mail address."""

    email = email.strip()
    console, buffer = _build_console()
    _prepare_config(
        console=console,
        verbose=verbose,
        filter_text=None,
        include_nsfw=include_nsfw,
        max_concurrent_requests=max_concurrent_requests,
    )

    if not email:
        return SearchOutcome(
            success=False,
            query=email,
            search_type="email",
            error="An email address is required to run the search.",
            log="",
        )

    _ensure_json_file(Path(config.EMAIL_LIST_PATH), "Email site list")

    config.currentEmail = email

    try:
        start = time.perf_counter()
        results = verifyEmail(email, config)
        elapsed = time.perf_counter() - start
    except Exception as exc:  # pragma: no cover - defensive guard
        log_text = console.export_text(clear=False)
        raise SearchServiceError("Email search failed. See the log for details.") from exc

    log_text = console.export_text(clear=False)
    accounts = _format_accounts(results)

    return SearchOutcome(
        success=True,
        query=email,
        search_type="email",
        accounts=accounts,
        log=log_text,
        elapsed=elapsed,
    )
